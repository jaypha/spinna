/*
 * Token source file for the Fig configuration language.
 * Processed by Flex into C source code.
 *
 * Part of the Fig configuration language project.
 *
 * Copyright Jaypha 2013.
 *
 * Distributed under the Boost Software License, Version 1.0.
 * (See http://www.boost.org/LICENSE_1_0.txt)
 *
 * Authors: Jason den Dulk
 */

%{
/*
 * Tokenises a Fig configuration file.
 *
 * Part of the Fig configuration language project.
 */

#include <string.h>
#include "defs.h"
#include "grammer.h"  /* Generated by bison. */

char* include_stack[MAX_FNAME_DEPTH];
int include_stack_ptr = 0;
%}

%option reentrant
%option bison-bridge
%option header-file="lex.h"
%option noyywrap
%option yylineno

%x str
%x comment
%x dcomment
%x incl

dseq      ([[:digit:]]+)
dseq_opt  ([[:digit:]]*)
frac      (({dseq_opt}"."{dseq})|{dseq}".")
exp       ([eE][+-]?{dseq})
exp_opt   ({exp}?)
fsuff     [flFL]
fsuff_opt ({fsuff}?)
dfc       (({frac}{exp_opt}{fsuff_opt})|({dseq}{exp}{fsuff_opt}))

%%
  int dnest = 0;
  char string_buf[1000]; // TODO make safer (strings can be of any size).
  char *string_buf_ptr;

  /* whitespace ------------------------------------------------------ */
  
[ \r\t]+    /* skip whitespace */
\n          /* skip newlines (increments linecounter) */

  /* C style comment ------------------------------------------------- */

"/*"         BEGIN(comment);

<comment>{

[^*\n]*        /* eat anything that's not a '*' */
"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
\n             /* skip newlines (increments linecounter) */
"*/"        BEGIN(INITIAL);
}

  /* D style comment ------------------------------------------------- */

"/+"         { ++dnest; BEGIN(dcomment); }

<dcomment>{
"/+"          ++dnest;
[^+/\n]*        /* eat anything that's not a '+' or a '/' */
"+"+[^+/\n]*   /* eat up '+'s not followed by '/'s */
"/"+[^/+\n]*   /* eat up '/'s not followed by '+'s */
\n             /* skip newlines (increments linecounter) */
"+/"        { if (--dnest == 0) BEGIN(INITIAL); }
}

  /* line comment ---------------------------------------------------- */

(#|"//")[^\n]*

  /* include files --------------------------------------------------- */

include             BEGIN(incl);
     
<incl>{

[ \t]*      /* eat the whitespace */
[^ \t\r\n]+   { /* got the include file name */
      yyin = fopen( yytext, "r" );
     
      if ( ! yyin )
      {
       yylval->strval = strdup("unable to open include file");
       BEGIN(INITIAL);
       return TOK_UNKNOWN;
      }
      include_stack[++include_stack_ptr] = strdup(yytext);

 			yypush_buffer_state(yy_create_buffer( yyin, YY_BUF_SIZE, yyscanner ), yyscanner);
     
      BEGIN(INITIAL);
  }
}

  /* boolean literals ------------------------------------------------ */

"t"("rue")?    { yylval->strval = strdup(yytext); return TOK_BOOL; }
"f"("alse")?   { yylval->strval = strdup(yytext); return TOK_BOOL; }

  /* integer literals ------------------------------------------------ */

[-+]?([[:digit:]]{-}[0])[[:digit:]]* { yylval->strval = strdup(yytext); return TOK_INT; }
0[xX][[:xdigit:]]+  { yylval->strval = strdup(yytext); return TOK_INT; }
0[01234567]+  { yylval->strval = strdup(yytext); return TOK_INT; }

  /* floating point literal ------------------------------------------ */

[-+]?{dfc}  { yylval->strval = strdup(yytext); return TOK_FLOAT; }

  /* string literal -------------------------------------------------- */

\"      string_buf_ptr = string_buf; BEGIN(str);

<str>{
\"        { /* saw closing quote - all done */
       BEGIN(INITIAL);
       *string_buf_ptr = '\0';
       yylval->strval = strdup(string_buf);
       return TOK_STR;
       /* return string constant token type and
        * value to parser
        */
       }

\n        {
       /* error - unterminated string constant */
       yylval->strval = strdup("unterminated string constant");
       BEGIN(INITIAL);
       return TOK_UNKNOWN;
       }

<<EOF>>   {
       /* error - unterminated string constant */
       yylval->strval = strdup("unterminated string constant");
       BEGIN(INITIAL);
       return TOK_UNKNOWN;
       }

\\x[0-9a-fA-F]{2} {
      /* hex escape sequence */
       int result;

       (void) sscanf( yytext + 2, "%x", &result );

       *string_buf_ptr++ = result;
      }

\\n  *string_buf_ptr++ = '\n';
\\t  *string_buf_ptr++ = '\t';
\\r  *string_buf_ptr++ = '\r';
\\\"  *string_buf_ptr++ = '\"';
\\\\  *string_buf_ptr++ = '\\';
\\.  *string_buf_ptr++ = yytext[1];

[^\\\n\"]+        {
       char *yptr = yytext;

       while ( *yptr )
               *string_buf_ptr++ = *yptr++;
       }
}


  /* identifier literal ----------------------------------------------- */

([_[:alpha:]])([_[:alnum:]-])* { yylval->strval = strdup(yytext); return TOK_NAME; }

  /* punctuation ------------------------------------------------------ */

[{};,:] { return yytext[0]; }

. {
    yylval->strval = strdup("unknown character '0'");
    yylval->strval[19] = yytext[0];
    return TOK_UNKNOWN;
}

<<EOF>> {
			yypop_buffer_state(yyscanner);
      --include_stack_ptr;
      if ( !YY_CURRENT_BUFFER )
      {
        yyterminate();
      }
  }
