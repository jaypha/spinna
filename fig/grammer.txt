/*
 * Grammer source file for the Fig configuration language.
 * Processed by Bison into C source code.
 *
 * Part of the Fig configuration language project.
 *
 * Copyright Jaypha 2013.
 *
 * Distributed under the Boost Software License, Version 1.0.
 * (See http://www.boost.org/LICENSE_1_0.txt)
 *
 * Authors: Jason den Dulk
 */

%{
/*
 * This parser parses a Fig configuration file.
 *
 * Part of the Fig configuration language project.
 */

#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>
#include "defs.h"
#define YYERROR_VERBOSE

Fig_Record* new_fig(enum Fig_Type type);
%}


%union
{
  char* strval;
  Fig_Record* value;
}

%token <strval> TOK_NAME
%token <strval> TOK_UNKNOWN
%token <strval> TOK_BOOL
%token <strval> TOK_INT
%token <strval> TOK_FLOAT
%token <strval> TOK_STR

%type <value> configuration;
%type <value> hash_list;
%type <value> hash_value;
%type <value> scalar_list;
%type <value> scalar_value;
%type <value> string_value;
%type <value> string;
%type <strval> hash_name;

%parse-param {fig_parse_context* context}
%pure-parser
%lex-param   {void* scanner}

%{
  #include "lex.h"

  #define scanner context->scanr

  void yyerror(fig_parse_context* context, char const *);
%}

%%

configuration : hash_list { context->content = $1; }

hash_list : { $$ = NULL; }
          | hash_value hash_list
            {
              $1->next = $2;
              $$ = $1;
            }

hash_value  : hash_name ';'
              {
                $$ = new_fig(Bool);
                $$->strval = strdup("true");
                $$->value.lval = 1;
                $$->name = $1;
              }
            | hash_name '{' hash_list '}'
              {
                $$ = new_fig(List);
                $$->value.list = $3;
                $$->name = $1;
              }
            | hash_name ':' scalar_list ';'
              {
                if ($3->next != NULL)
                {
                  $$ = new_fig(Array);
                  $$->value.list = $3;
                }
                else
                  $$ = $3;
                $$->name = $1;
              }
;

hash_name : TOK_NAME { $$ = $1; }
          | TOK_BOOL { $$ = $1; }
;

scalar_list : scalar_value { $$ = $1; }
            | scalar_value ',' scalar_list
              {
                $1->next = $3;
                $$ = $1;
              }
;

scalar_value : TOK_INT { $$ = new_fig(Int); $$->strval = $1; $$->value.lval = strtol($$->strval,NULL,0); }
             | TOK_BOOL { $$ = new_fig(Bool); $$->strval = $1; $$->value.lval = ($$->strval[0] == 't');}
             | TOK_FLOAT { $$ = new_fig(Float); $$->strval = $1; $$->value.dval = atof($$->strval); }
             | string_value
;

string_value  : string { $$ = $1; }
              | string string_value
                {
                  char* newstr = malloc(strlen($1->strval) + strlen($2->strval)+1);
                  strcpy(newstr, $1->strval);
                  free($1->strval);
                  $1->strval = strcat(newstr, $2->strval);
                  free($2->strval);
                  free($2);
                  $$ = $1;
                }
;

string : TOK_NAME { $$ = new_fig(Str); $$->strval = $1; }
       | TOK_STR { $$ = new_fig(Str); $$->strval = $1; }
;

%%

#include <ctype.h>

/*-------------------------------------------------------------------------
 * Allocates and initialises a fig value record. */

Fig_Record* new_fig(enum Fig_Type type)
{
  Fig_Record* val;
  val = malloc(sizeof(Fig_Record));
  val->name = NULL;
  val->next = NULL;
  val->strval = NULL;
  val->type = type;
  //if (type == Binary)
  //{
  //  val->value.bval.data = NULL;
  //  val->value.bval.length = 0;
  //}
  //else
    val->value.list = NULL;
  return val;
}

/*-------------------------------------------------------------------------
 * Frees a value record and all its content. */

void free_fig_record(Fig_Record* val)
{
  if (val != NULL)
  {
    if (val->next != NULL) free_fig_record(val->next);
    if (val->name != NULL) free(val->name);
    if (val->strval != NULL) free(val->strval);
    if (val->type == List || val->type == Array)
      { if (val->value.list != NULL) free_fig_record(val->value.list); }
    //else if (val->type == Binary && val->value.bval.data !=NULL)
    //  free(val->value.bval.data);

    free(val);
  }
}

/*-------------------------------------------------------------------------
 * Frees a context and its record */

void free_fig_context(Fig_Context* context)
{
  if (context != NULL)
  {
    if (context->err_message != NULL)
      free(context->err_message);
    if (context->content != NULL)
      free_fig_record(context->content);
  }
}

/*-------------------------------------------------------------------------
 * Main routine.
 * Read the file, parse contents,
 * return content and/or error details.
 */

Fig_Context* read_fig(FILE* in)
{
  fig_parse_context* context = malloc(sizeof(fig_parse_context));
  context->content = NULL;
  context->err_line_no = 0;


  if (in != NULL)
  {
    context->err_message = NULL;
    
    yylex_init ( &context->scanr );
    yyset_in( in, context->scanr );
    yyparse(context);
    yylex_destroy ( context->scanr );
    fclose(in);
  }
  else
    context->err_message = strdup("cannot open input file");

  Fig_Context* ret_val = malloc(sizeof(Fig_Context));
  ret_val->content     = context->content;
  ret_val->err_line_no = context->err_line_no;
  ret_val->err_column  = context->err_column;
  ret_val->err_message = context->err_message;
  ret_val->err_filename = context->err_filename;
  
  free(context);

  return ret_val;
}

Fig_Context* read_figfile(char* filepath)
{
  FILE *in;
  char *curwd = NULL;
  char path[1024];
  char* filename;
  char *ptr;

  ptr = strrchr(filepath,'/');
  filename = filepath;

  if (ptr)
  {
    strncpy(path,filename,ptr-filename);
    path[ptr-filename] = '\0';
    filename = ptr+1;

    curwd = get_current_dir_name();
    chdir(path);
  }
    
  include_stack[include_stack_ptr] = strdup(filename);

  in = fopen( filename, "r" );

  Fig_Context* ret_val = read_fig(in);
  
  if (ptr)
  {
    chdir(curwd);
    free(curwd);
  }

  return ret_val;
}

/*-------------------------------------------------------------------------
 * Error handling */

void yyerror(fig_parse_context* context, char const *s)
{
  YYSTYPE* yys;
  yys = yyget_lval(context->scanr);
  if (yys != NULL)
  {
    int l1, l2;
    l1 = strlen(s);
    l2 = strlen(yys->strval);
    context->err_message = malloc(l1+l2+200);
    memcpy(context->err_message, s,l1);
    memcpy(context->err_message+l1, " (actually read '",17);
    memcpy(context->err_message+l1+17,yys->strval,l2);
    context->err_message[l1+l2+17] = '\'';
    context->err_message[l1+l2+18] = ')';
    context->err_message[l1+l2+19] = 0;
  }
  else
    context->err_message = strdup(s);

  context->err_line_no = yyget_lineno(context->scanr);
  context->err_column = yyget_column(context->scanr);
  context->err_filename = strdup(include_stack[include_stack_ptr]);

  if (context->content != NULL)
  {
    free_fig_record(context->content);
    context->content = NULL;
  }
}

/*-------------------------------------------------------------------------*/
